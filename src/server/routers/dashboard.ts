import { z } from 'zod'
import { router, protectedProcedure } from '../trpc'
import { supabase } from '@/infra/supabase/client'

export const dashboardRouter = router({
  /**
   * Get dashboard statistics
   */
  getStats: protectedProcedure
    .input(
      z.object({
        outletId: z.string().uuid().optional(),
        startDate: z.string().optional(),
        endDate: z.string().optional(),
      }).optional()
    )
    .query(async ({ input }) => {
      const today = new Date().toISOString().split('T')[0]
      const startDate = input?.startDate || today
      const endDate = input?.endDate || today

      // Get total products
      const { count: totalProducts } = await supabase
        .from('products')
        .select('*', { count: 'exact', head: true })

      // Get total outlets
      const { count: totalOutlets } = await supabase
        .from('outlets')
        .select('*', { count: 'exact', head: true })

      // Get sales from transactions table (more reliable than daily_sales)
      let transactionsQuery = supabase
        .from('transactions')
        .select('total_amount, created_at, transaction_items(quantity)')
        .eq('status', 'completed')
        .gte('created_at', `${startDate}T00:00:00`)
        .lte('created_at', `${endDate}T23:59:59`)

      if (input?.outletId) {
        transactionsQuery = transactionsQuery.eq('outlet_id', input.outletId)
      }

      const { data: transactions } = await transactionsQuery

      const totalRevenue = transactions?.reduce((sum, tx) => sum + (tx.total_amount || 0), 0) || 0
      const totalItemsSold = transactions?.reduce((sum, tx) => {
        return sum + (tx.transaction_items?.reduce((itemSum: number, item: any) => itemSum + (item.quantity || 0), 0) || 0)
      }, 0) || 0

      // Get low stock items (stock < 10)
      let stockQuery = supabase
        .from('daily_stock')
        .select('product_id, stock_akhir, stock_date')
        .eq('stock_date', today)
        .lt('stock_akhir', 10)

      if (input?.outletId) {
        stockQuery = stockQuery.eq('outlet_id', input.outletId)
      }

      const { data: lowStockData, count: lowStockCount } = await stockQuery

      return {
        totalProducts: totalProducts || 0,
        totalOutlets: totalOutlets || 0,
        totalRevenue,
        totalItemsSold,
        lowStockCount: lowStockCount || 0,
        transactionCount: transactions?.length || 0,
      }
    }),

  /**
   * Get sales trend (last 7 days) - from transactions table
   */
  getSalesTrend: protectedProcedure
    .input(
      z.object({
        outletId: z.string().uuid().optional(),
        days: z.number().default(7),
      }).optional()
    )
    .query(async ({ input }) => {
      const days = input?.days || 7
      const endDate = new Date()
      const startDate = new Date()
      startDate.setDate(startDate.getDate() - (days - 1))

      // Query from transactions table
      let query = supabase
        .from('transactions')
        .select('created_at, total_amount, transaction_items(quantity)')
        .eq('status', 'completed')
        .gte('created_at', `${startDate.toISOString().split('T')[0]}T00:00:00`)
        .lte('created_at', `${endDate.toISOString().split('T')[0]}T23:59:59`)
        .order('created_at', { ascending: true })

      if (input?.outletId) {
        query = query.eq('outlet_id', input.outletId)
      }

      const { data: transactions } = await query

      // Group by date
      const trendMap: Record<string, { date: string; revenue: number; itemsSold: number }> = {}

      // Initialize all dates
      for (let i = 0; i < days; i++) {
        const date = new Date(startDate)
        date.setDate(date.getDate() + i)
        const dateStr = date.toISOString().split('T')[0]
        trendMap[dateStr] = { date: dateStr, revenue: 0, itemsSold: 0 }
      }

      // Fill with actual data from transactions
      transactions?.forEach((tx: any) => {
        const txDate = new Date(tx.created_at).toISOString().split('T')[0]
        if (trendMap[txDate]) {
          trendMap[txDate].revenue += tx.total_amount || 0
          // Sum all items quantity
          const itemsCount = tx.transaction_items?.reduce((sum: number, item: any) => sum + (item.quantity || 0), 0) || 0
          trendMap[txDate].itemsSold += itemsCount
        }
      })

      return Object.values(trendMap)
    }),

  /**
   * Get top selling products - from transactions table
   */
  getTopProducts: protectedProcedure
    .input(
      z.object({
        outletId: z.string().uuid().optional(),
        limit: z.number().default(5),
        days: z.number().default(7),
      }).optional()
    )
    .query(async ({ input }) => {
      const days = input?.days || 7
      const limit = input?.limit || 5

      const endDate = new Date()
      const startDate = new Date()
      startDate.setDate(startDate.getDate() - (days - 1))

      // Query from transactions table with transaction_items
      let query = supabase
        .from('transactions')
        .select(`
          transaction_items (
            product_id,
            product_name,
            product_sku,
            quantity,
            line_total
          )
        `)
        .eq('status', 'completed')
        .gte('created_at', `${startDate.toISOString().split('T')[0]}T00:00:00`)
        .lte('created_at', `${endDate.toISOString().split('T')[0]}T23:59:59`)

      if (input?.outletId) {
        query = query.eq('outlet_id', input.outletId)
      }

      const { data: transactions } = await query

      // Group by product
      const productMap: Record<string, {
        productId: string
        productName: string
        productSku: string
        totalQuantity: number
        totalRevenue: number
      }> = {}

      // Flatten transaction_items and aggregate by product
      transactions?.forEach((tx: any) => {
        tx.transaction_items?.forEach((item: any) => {
          if (!productMap[item.product_id]) {
            productMap[item.product_id] = {
              productId: item.product_id,
              productName: item.product_name || 'Unknown',
              productSku: item.product_sku || 'N/A',
              totalQuantity: 0,
              totalRevenue: 0,
            }
          }
          productMap[item.product_id].totalQuantity += item.quantity || 0
          productMap[item.product_id].totalRevenue += item.line_total || 0
        })
      })

      // Sort and limit
      const topProducts = Object.values(productMap)
        .sort((a, b) => b.totalQuantity - a.totalQuantity)
        .slice(0, limit)

      return topProducts
    }),

  /**
   * Get low stock products (OPTIMIZED - using JOIN to avoid N+1)
   */
  getLowStock: protectedProcedure
    .input(
      z.object({
        outletId: z.string().uuid().optional(),
        threshold: z.number().default(10),
      }).optional()
    )
    .query(async ({ input }) => {
      const today = new Date().toISOString().split('T')[0]
      const threshold = input?.threshold || 10

      // OPTIMIZED: Use JOIN to fetch all data in a single query
      let query = supabase
        .from('daily_stock')
        .select(`
          product_id,
          outlet_id,
          stock_akhir,
          stock_date,
          products!inner(id, name, sku, category),
          outlets!inner(id, name)
        `)
        .eq('stock_date', today)
        .lt('stock_akhir', threshold)
        .order('stock_akhir', { ascending: true })

      if (input?.outletId) {
        query = query.eq('outlet_id', input.outletId)
      }

      const { data: stockData } = await query

      if (!stockData || stockData.length === 0) return []

      // Map the joined data
      return stockData.map((stock: any) => ({
        productId: stock.product_id,
        productName: stock.products?.name || 'Unknown',
        productSku: stock.products?.sku || 'N/A',
        productCategory: stock.products?.category || null,
        outletId: stock.outlet_id,
        outletName: stock.outlets?.name || 'Unknown',
        currentStock: stock.stock_akhir,
        date: stock.stock_date,
      }))
    }),

  /**
   * Get recent transactions (MIGRATED - using transactions table for reliability)
   */
  getRecentTransactions: protectedProcedure
    .input(
      z.object({
        outletId: z.string().uuid().optional(),
        limit: z.number().default(10),
      }).optional()
    )
    .query(async ({ input }) => {
      const limit = input?.limit || 10

      // Query from transactions table with JOIN to get all related data
      let query = supabase
        .from('transactions')
        .select(`
          id,
          transaction_id,
          outlet_id,
          status,
          total_amount,
          created_at,
          transaction_items (
            product_id,
            product_name,
            product_sku,
            quantity,
            unit_price,
            line_total
          ),
          outlets!inner(id, name),
          cashier:users!cashier_id(id, name, email)
        `)
        .order('created_at', { ascending: false })
        .limit(limit)

      if (input?.outletId) {
        query = query.eq('outlet_id', input.outletId)
      }

      const { data: transactions } = await query

      if (!transactions || transactions.length === 0) return []

      // Map transactions to flat format for compatibility with existing UI
      // Each transaction item becomes a separate row
      const flatTransactions: any[] = []

      transactions.forEach((tx: any) => {
        if (tx.transaction_items && tx.transaction_items.length > 0) {
          tx.transaction_items.forEach((item: any) => {
            flatTransactions.push({
              id: `${tx.id}-${item.product_id}`,
              transactionId: tx.transaction_id,
              productName: item.product_name,
              productSku: item.product_sku || 'N/A',
              outletName: tx.outlets?.name || 'Unknown',
              cashierName: tx.cashier?.name || 'Unknown',
              date: tx.created_at,
              quantity: item.quantity,
              revenue: item.line_total,
              status: tx.status,
              totalAmount: tx.total_amount,
              createdAt: tx.created_at,
            })
          })
        } else {
          // Transaction without items (shouldn't happen, but handle gracefully)
          flatTransactions.push({
            id: tx.id,
            transactionId: tx.transaction_id,
            productName: 'No items',
            productSku: 'N/A',
            outletName: tx.outlets?.name || 'Unknown',
            cashierName: tx.cashier?.name || 'Unknown',
            date: tx.created_at,
            quantity: 0,
            revenue: 0,
            status: tx.status,
            totalAmount: tx.total_amount,
            createdAt: tx.created_at,
          })
        }
      })

      return flatTransactions
    }),
})
